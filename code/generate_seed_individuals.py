'''
This file generates the seed individuals used for the tests with the Sphere, Rastrigin, and Rosenbrock functions. It requires the initial populations generated by "generate_initial_populations.py".
'''
import os
import math
import warnings

import numpy as np
import pandas as pd

from scipy import optimize

from pymoo.core.problem import Problem


from problems.sphere import Sphere

# ====================================================================================================
# Define hepler class and functions
# ====================================================================================================

class Problem_To_Optimize:
    def __init__(self, problem: Problem, percentage_of_optimal_genes: float, fitness_target: float) -> None:
        '''
        TODO: describe what this class does
        '''
        self.problem = problem
        self.percentage_of_optimal_genes = percentage_of_optimal_genes
        self.fitness_target = fitness_target
    
    def to_optimize_with_scipy(self, x):
        '''
        This method is specificically designed to be optimized with scipy.
        '''
        ind = generate_so_genome(
            non_optimal_gene_value=x,
            percentage_of_optimal_genes=self.percentage_of_optimal_genes,
            problem=self.problem)

        #return my_func - self.fitness_target #TODO: test
        return self.problem.evaluate(ind) - self.fitness_target


def generate_so_genome(non_optimal_gene_value:float, percentage_of_optimal_genes:float, problem:Problem):
    '''
    This method generates an individual for a single-objective problem systematically as used often in this paper.
    #TODO: better description

    Parameters:
    -----------
    percentage_of_optimal_genes : float
        The percentage of genome values to be optimal.
    non_optimal_gene_value : float
        The value all non-optimal genes will have.
    problem : pymoo.core.Problem
        The problem for which the individual will be generated, specifying the dimensionality and pareto set used for the optimal genome values.

    Returns:
    --------
    genome : np.array()
        The genome derived from the values.
    '''
    number_optimal_genes = int(percentage_of_optimal_genes * problem.n_var)
    number_not_optimal_genes = problem.n_var - number_optimal_genes
    
    optimal_ind = problem._calc_pareto_set().astype(float) #for some reason pymoo returns some pareto sets with type int
    optimal_ind[:number_not_optimal_genes] = non_optimal_gene_value

    return optimal_ind

def calculate_non_optimal_genome_values(problem: Problem, percentage_of_optimal_genes: float, fitness_target: float):
    '''
    Finds the genome values of a nonlinear benchmarking function, like the Rastrigin or Rosenbrock function.
    The solutions found assume every genome value of the not optimal genes to be the same.
    Multiple (or none) not optimal genome values can be found and are returned as a list.
    '''

    scipy_optimizable_problem = Problem_To_Optimize(
        problem=problem,
        fitness_target=fitness_target,
        percentage_of_optimal_genes=percentage_of_optimal_genes
    )

    results = []
    for i in np.linspace(problem.xl[0], problem.xu[0], 101): #TODO: hint that it only works with the same xl and xu for all genes!
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            current_res = optimize.fsolve(func=scipy_optimizable_problem.to_optimize_with_scipy, x0=[i])

        if math.isclose(a=scipy_optimizable_problem.to_optimize_with_scipy(current_res), b=0.0, abs_tol=0.000000001):#check if the result is generally good enough
            if len(results) > 0: #if we already have found solutions we need to ckeck for duplicates
                closest_found_res = results[min(range(len(results)), key = lambda i: abs(results[i]-current_res))] #the closest result already found in the list
                if math.isclose(a=current_res, b=closest_found_res, abs_tol=0.000000001):#check if we already have a solution for this genome value
                    if scipy_optimizable_problem.to_optimize_with_scipy(current_res) < scipy_optimizable_problem.to_optimize_with_scipy(closest_found_res): #replace the found solution if the new one is better
                        results[results.index(closest_found_res)] = current_res[0]
                else:#if the result is not close, add to the list
                    results.append(current_res[0])
            else:#if the list is empty, insert the first result
                results.append(current_res[0])    
    
    return np.array( results )

def generate_individuals(problem: Problem, percentage_of_optimal_genes: float, fitness_target: float) -> np.array:
    '''
    Calculates possible seed individuals for a given fitness target.
    Returns a numpy array of individuals.
    '''
    genome_values = calculate_non_optimal_genome_values(problem, percentage_of_optimal_genes, fitness_target)
    whole_individuals = [ generate_so_genome(non_optimal_gene_value, percentage_of_optimal_genes, problem) for non_optimal_gene_value in genome_values ]

    return np.array(whole_individuals)

def build_dataframe_for_fitness_target(problem:Problem, f_target: float, quality:str, seed_inds_df:pd.DataFrame) -> None:
    '''
    This method generates the dataframe for different percentages of optimal genes.
    The results will be saved to the seed_inds_df.
    '''
    for percentage_of_optimal_genes in [0.0, 0.25, 0.5, 0.75]: #the four percentages of optimal genes used
        # 1. generate possible individuals
        individuals = generate_individuals(
            problem=problem,
            percentage_of_optimal_genes=percentage_of_optimal_genes,
            fitness_target=f_target
            )
        #2. Skip the configuration if less than two are found
        if len(individuals) < 2:
            print("Less than two solutions found for problem", type(problem).__name__,"in qualiry", quality ,", skipping", percentage_of_optimal_genes,"optimal genes...")
            continue
        #3. If 2 or more, select the min and max distance to the pareto set
        else:
            dists_to_optimim = np.array( [np.linalg.norm( problem._calc_pareto_set()-ind ) for ind in individuals]) #euclidean distance
            max_dist_id = np.argmax(dists_to_optimim)
            min_dist_id = np.argmin(dists_to_optimim)
            f_of_individuals = problem.evaluate(individuals)
            seed_inds_df.loc[len(seed_inds_df)+1] =list(individuals[ min_dist_id ]) + [dists_to_optimim[min_dist_id], "close", percentage_of_optimal_genes, quality, f_of_individuals[ min_dist_id ][0] ]#0 because single objective
            seed_inds_df.loc[len(seed_inds_df)+1] =list(individuals[ max_dist_id ]) + [dists_to_optimim[max_dist_id], "far", percentage_of_optimal_genes, quality, f_of_individuals[ max_dist_id ][0] ]


def generate_seed_inds_for_problem_and_dim(problem:Problem, problem_name:str, dim:int, random_inds:np.array) -> None:
    '''
    Generates and saves seed individuals to a csv file.
    '''
    #fitness gargets:
    f_of_random_inds = problem.evaluate(random_inds)
    f_best = np.min(f_of_random_inds) / 2
    f_lower_quartile = np.quantile(f_of_random_inds, 0.25)
    f_median = np.median(f_of_random_inds)
    f_upper_quartile = np.quantile(f_of_random_inds, 0.75)
    f_worst = np.max(f_of_random_inds) * 2

    df_columns = ["gene_"+str(i) for i in range(dim)] + ["euclidean distance","close/far","% optimal genes","quality","fitness"]
    seed_inds_df = pd.DataFrame(columns=df_columns, dtype=str)

    build_dataframe_for_fitness_target(problem, f_best, "best", seed_inds_df)
    build_dataframe_for_fitness_target(problem, f_lower_quartile, "lower quartile", seed_inds_df)
    build_dataframe_for_fitness_target(problem, f_median, "median", seed_inds_df)
    build_dataframe_for_fitness_target(problem, f_upper_quartile, "upper quartile", seed_inds_df)
    build_dataframe_for_fitness_target(problem, f_worst, "worst", seed_inds_df)

    seed_inds_df.to_csv("../data/seed_individuals/seed_individuals_"+problem_name+"_"+str(dim)+".csv")

# ====================================================================================================
# Actually generating the individuals
# ====================================================================================================


#check if the output path exists
out_path = "../data/seed_individuals"
if not os.path.exists(out_path):
   os.makedirs(out_path)

#set the randon seed
np.random.seed(1)

#read the initial populations
in_path = "../data/initial_populations"
random_inds_d4 = np.loadtxt(in_path+"/random_inds_d4.csv", delimiter=",", dtype=float)
random_inds_d8 = np.loadtxt(in_path+"/random_inds_d8.csv", delimiter=",", dtype=float)
random_inds_d16 = np.loadtxt(in_path+"/random_inds_d16.csv", delimiter=",", dtype=float)
random_inds_d32 = np.loadtxt(in_path+"/random_inds_d32.csv", delimiter=",", dtype=float)

# ====================================================================================================
# Generate the seed individuals for the Rastrigin and Rosenbrock Functions
# ====================================================================================================

xl = -5
xu = 5

# dim = 4
# generate_seed_inds_for_problem_and_dim(Rastrigin(n_var = dim, xl=xl, xu=xu), "Rastrigin", dim, random_inds_d4)
# generate_seed_inds_for_problem_and_dim(Rosenbrock(n_var = dim, xl=xl, xu=xu), "Rosenbrock", dim, random_inds_d4)
# dim = 8
# generate_seed_inds_for_problem_and_dim(Rastrigin(n_var = dim, xl=xl, xu=xu), "Rastrigin", dim, random_inds_d8)
# generate_seed_inds_for_problem_and_dim(Rosenbrock(n_var = dim, xl=xl, xu=xu), "Rosenbrock", dim, random_inds_d8)
# dim = 16
# generate_seed_inds_for_problem_and_dim(Rastrigin(n_var = dim, xl=xl, xu=xu), "Rastrigin", dim, random_inds_d16)
# generate_seed_inds_for_problem_and_dim(Rosenbrock(n_var = dim, xl=xl, xu=xu), "Rosenbrock", dim, random_inds_d16)
# dim = 32
# generate_seed_inds_for_problem_and_dim(Rastrigin(n_var = dim, xl=xl, xu=xu), "Rastrigin", dim, random_inds_d32)
# generate_seed_inds_for_problem_and_dim(Rosenbrock(n_var = dim, xl=xl, xu=xu), "Rosenbrock", dim, random_inds_d32)


# ====================================================================================================
# Also generate the seed individuals for the sphere function, which can be solved systhematically
# ====================================================================================================

def generate_sphere_individual(n_var: int, target_fitness: float, seed_quality:str, problem:Sphere, seed_inds_df=pd.DataFrame):
    print("target", target_fitness)
    for percentage_of_optimal_genes in [0.0, 0.25, 0.5, 0.75]:
        number_optimal_genes = int(percentage_of_optimal_genes * n_var)
        number_not_optimal_genes = n_var - number_optimal_genes

        ind = np.zeros(n_var)
        ind[:number_not_optimal_genes] = np.sqrt(target_fitness/number_not_optimal_genes)

        dist_to_optimum = np.linalg.norm( problem._calc_pareto_set()-ind )
        f_of_ind = problem.evaluate(np.array([ind]))[0][0]

        print("real", f_of_ind, ind)
        seed_inds_df.loc[len(seed_inds_df)+1] =list(ind) + [dist_to_optimum, "equal", percentage_of_optimal_genes, seed_quality, f_of_ind ]
    exit()
    return ind


def generate_seeds_for_sphere_function(problem: Sphere, n_var: int, initial_pop: np.array):
    seed_inds = np.zeros((18, n_var))

    #set the utopia and dystopia points
    seed_inds[0] = np.zeros(n_var)
    seed_inds[1] = np.ones(n_var) * 5

    #calculate the target fitness of the quartiles
    initial_pop_fitness = problem.evaluate(initial_pop)
    best = np.min(initial_pop_fitness) / 2
    lower_quartile = np.quantile(initial_pop_fitness, 0.25)
    median = np.median(initial_pop_fitness)
    upper_quartile = np.quantile(initial_pop_fitness, 0.75)
    worst = np.max(initial_pop_fitness) * 2


    df_columns = ["gene_"+str(i) for i in range(dim)] + ["euclidean distance","close/far","% optimal genes","quality","fitness"]
    seed_inds_df = pd.DataFrame(columns=df_columns, dtype=str)

    generate_sphere_individual(n_var, best, "best", problem, seed_inds_df)
    generate_sphere_individual(n_var, lower_quartile, "lower quartile", problem, seed_inds_df)
    generate_sphere_individual(n_var, median, "median", problem, seed_inds_df)
    generate_sphere_individual(n_var, upper_quartile, "upper quartile", problem, seed_inds_df)
    generate_sphere_individual(n_var, worst, "worst", problem, seed_inds_df)

    print(seed_inds_df)
    exit()
    seed_inds_df.to_csv("../data/seed_individuals/seed_individuals_Sphere_"+str(dim)+".csv")

dim = 4
generate_seeds_for_sphere_function(Sphere(n_var = dim, xl=xl, xu=xu), dim, random_inds_d4)
dim = 8
generate_seeds_for_sphere_function(Sphere(n_var = dim, xl=xl, xu=xu), dim, random_inds_d8)
dim = 16
generate_seeds_for_sphere_function(Sphere(n_var = dim, xl=xl, xu=xu), dim, random_inds_d16)
dim = 32
generate_seeds_for_sphere_function(Sphere(n_var = dim, xl=xl, xu=xu), dim, random_inds_d32)