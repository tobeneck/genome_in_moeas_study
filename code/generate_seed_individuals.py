'''
This file generates the seed individuals used for the tests with the Sphere, Rastrigin, and Rosenbrock functions. It requires the initial populations generated by "generate_initial_populations.py".
'''


import os
import numpy as np
import pandas as pd
from pymoo.core.problem import Problem
from pymoo.operators.sampling.rnd import FloatRandomSampling

from test_setup import problems

#check if the output path exists
out_path = "../data/seed_individuals"
if not os.path.exists(out_path):
   os.makedirs(out_path)


def save_dataframe(seed_genomes:list, random_genomes:list, problem:Problem, problem_name:str, seed_types:list, random_types:list):
    '''
    Save the seed ind combinations for 2 objectives to a csv file.

    Parameters:
    -----------
    seed_genomes: list of np.arrays
        The genomes of the seed individuals. The last element is always the center, the first elements always the extreme solutions.
    random_genomes: list of np.arrays
        The genomes of the random individuals.
    problem: pymoo.core.problem
        The problem the seed inds are generated for.
    problem_name: str
        The name of the problem the seed inds are generated for.
    seed_types: list of str
        The types of the seed individuals (extreme or center).
    random_types: list of str
        The types of the random individuals (1-4).
    '''
    #evaluate the genomes
    seed_inds_f = [ problem.evaluate(ind) for ind in seed_genomes ]
    random_inds_f = [ problem.evaluate(ind) for ind in random_genomes ]

    #set up the dataframe:
    df_columns = ["gene_"+str(i+1) for i in range(problem.n_var)] + ["obj_"+str(i+1) for i in range(problem.n_obj)] + ["type"]
    seed_inds_df = pd.DataFrame(columns=df_columns, dtype=str)
    #save the seed types:
    for i in range(len(seed_types)):
        seed_inds_df.loc[len(seed_inds_df)+1] = list(seed_genomes[i]) + list(seed_inds_f[i]) + [seed_types[i]]
    #save the random types:
    for i in range(len(random_types)):
        seed_inds_df.loc[len(seed_inds_df)+1] = list(random_genomes[i]) + list(random_inds_f[i]) + [random_types[i]]
    seed_inds_df.to_csv(out_path + "/seed_individuals_" + problem_name + ".csv")


def calc_distance_to_reference_vector(point, reference_vector, line_origin):
    '''
    Calculate the distance of a point to a reference vector. The reference vector is assumed to go through the origin.

    Parameters:
    -----------
    point: np.array
        The point to calculate the distance to the reference vector.
    reference_vector: np.array
        The reference vector.

    Returns:
    --------
    float
        The distance of the point to the reference vector.
    '''

    dist = np.linalg.norm(np.cross(reference_vector-line_origin, line_origin-point))/np.linalg.norm(reference_vector-line_origin) #the perpendicular distance / distance from a point to a line

    return dist

def get_closest_point_to_line(point_set, reference_vector, line_origin):
    '''
    Get the point in the point_set that is closest to the reference vector.

    Parameters:
    -----------
    point_set: np.array
        The set of points to find the closest point to the reference vector.
    reference_vector: np.array
        The reference vector.

    Returns:
    --------
    int
        The index of the point in the point_set that is closest to the reference vector.
    float
        The distance of the point in the point_set that is closest to the reference vector.
    '''

    min_d = float("inf")
    index = -1
    for i, point in enumerate(point_set):
        d = calc_distance_to_reference_vector(point, reference_vector, line_origin)
        if d < min_d:
            min_d = d
            index = i

    return index, min_d

#set the randon seed
np.random.seed(1)

#generate three random inds #TODO: this is wrong! Random inds need to also be generated within the bounds of the problem, so for each problem individually!
random_seed_types = ["r1", "r2", "r3", "r4"]
d2_seed_types = ["e1", "e2", "c"]
d3_seed_types = ["e1", "e2", "e3", "c"]

sampler = FloatRandomSampling()

# =============================================================================
# Generate the seed individuals with the reference vectors
# =============================================================================


for problem_name in problems.keys():
    # if "MACO" in problem_name: #no need to re-generate MACO
    #     continue
    
    problem = problems[problem_name]
    pareto_set_X = problem._calc_pareto_set(n_pareto_points=1005) #5 as it is not even and still meets the ZDT3 constraint
    pareto_set_F = problem.evaluate(pareto_set_X)

    upper_bounds = pareto_set_F.max(axis=0)
    lower_bounds = pareto_set_F.min(axis=0)

    random_inds_x = sampler._do(problem=problem, n_samples=4)

    if problem.n_obj == 2:
        reference_vectors_d2 = [
            [lower_bounds[0], upper_bounds[1]],
            [upper_bounds[0], lower_bounds[1]],
            [upper_bounds[0], upper_bounds[1]]
        ]
        seed_inds_X = [
            pareto_set_X[ get_closest_point_to_line(pareto_set_F, reference_vectors_d2[0], line_origin=lower_bounds)[0] ], #e1
            pareto_set_X[ get_closest_point_to_line(pareto_set_F, reference_vectors_d2[1], line_origin=lower_bounds)[0] ], #e2
            pareto_set_X[ get_closest_point_to_line(pareto_set_F, reference_vectors_d2[2], line_origin=lower_bounds)[0] ] #c
        ]
        save_dataframe(seed_inds_X, random_inds_x, problem, problem_name, d2_seed_types, random_seed_types)
    elif problem.n_obj == 3:
        reference_vectors_d3 = [
            [lower_bounds[0], lower_bounds[1], upper_bounds[2]],
            [lower_bounds[0], upper_bounds[1], lower_bounds[2]],
            [upper_bounds[0], lower_bounds[1], lower_bounds[2]],
            [upper_bounds[0], upper_bounds[1], upper_bounds[2]]
        ]
        seed_inds_X = [
            pareto_set_X[ get_closest_point_to_line(pareto_set_F, reference_vectors_d3[0], line_origin=lower_bounds)[0] ], #e1
            pareto_set_X[ get_closest_point_to_line(pareto_set_F, reference_vectors_d3[1], line_origin=lower_bounds)[0] ], #e2
            pareto_set_X[ get_closest_point_to_line(pareto_set_F, reference_vectors_d3[2], line_origin=lower_bounds)[0] ], #e3
            pareto_set_X[ get_closest_point_to_line(pareto_set_F, reference_vectors_d3[3], line_origin=lower_bounds)[0] ] #c
        ]
        save_dataframe(seed_inds_X, random_inds_x, problem, problem_name, d3_seed_types, random_seed_types)